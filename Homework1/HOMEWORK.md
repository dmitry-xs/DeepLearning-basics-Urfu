# Домашняя работа №1
## Задание 1: Создание и манипуляции с тензорами
### 1.1 Создание тензоров
```
1. Для заполнения тензора рандомными числами от 0 до 1 используем метод rand модуля torch 
2. При создании тензора заполненого нулями используем torch.zeros, в параметрах через запятую указываем размерность тензора 
3. Для созжания тензора из единиц используем метод ones      
4. И для тензора заполненого последовательностью чисел от 0 до 15 используем arange, в параметрах указываем 0 и 16 т.к последнее число не учитывается при генерации.
```
### 1.2 Операции с тензорами
Создадим два тензора А и В и заполним из наприимер значениями от 0 до 12.
```
1. Для транспонирования тензора А используем А.Т
2. Для матричного умножения двух тензоров используем @
3. Для того чтобы поэлементно умножить два тензора используем привычный нам символ *
4. Для того чтобы посчитать сумму значений из тензора, воспользуемся методом sum из модуля торч, в и результате получаем тензор со значением 66, и с помощью item() возвращаем только сумму.
```
### 1.3 Индексация и срезы
Для начала сосздадим тензор размером 5х5х5, для этого воспользуемся torch.randint. Будем генерировать целые числа от 0 до 9. 
```
1. Возьмем первую строку (первой матрицы). Для этого выполним срез tensor[0, 0, :], где указываем, что берем нулевую матрицу, нудевую строку, и указываем все элементы в первой строке.
2. Чтобы взять последний столбец (например всех матриц) сделаем срез tensor[:, :, -1], где указываем, что берем все матрицы, все строки, и указываем с каждой строки последний элемент.
3. Для нахождения центральной подматрицы, сделаем срез tensor[2:4, 2:4, 2:4]. Срезы делаем по всем трем осям, чтобы получить центральный куб 2×2×2.
4. И чтобы извлечь все элементы с четными индексами, сделаем срез tensor[::2, ::2, ::2], то есть по каждой оси делаем шаг 2, это позволит проскочить нечетные индексы.
```
### 1.4 Работа с формами
Для изменения форм тензора можем воспользовать как reshape, так и view
## Задание 2: Автоматическое дифференцирование
### 2.1 Простые вычисления с градиентами

```python
f.backward()

print(f"Градиент по x: {x.grad.item()}")
print(f"Градиент по y: {y.grad.item()}")
print(f"Градиент по z: {z.grad.item()}")
```














